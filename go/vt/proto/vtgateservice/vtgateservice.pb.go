// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: vtgateservice.proto

package vtgateservice

import (
	context "context"
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	vtgate "vitess.io/vitess/go/vt/proto/vtgate"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("vtgateservice.proto", fileDescriptor_601ae27c95081e0f) }

var fileDescriptor_601ae27c95081e0f = []byte{
	// 265 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x2e, 0x2b, 0x49, 0x4f,
	0x2c, 0x49, 0x2d, 0x4e, 0x2d, 0x2a, 0xcb, 0x4c, 0x4e, 0xd5, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17,
	0xe2, 0x45, 0x11, 0x94, 0xe2, 0x81, 0x70, 0x21, 0x92, 0x46, 0x2d, 0xcc, 0x5c, 0x6c, 0x61, 0x99,
	0x25, 0xa9, 0xc5, 0xc5, 0x42, 0x36, 0x5c, 0xec, 0xae, 0x15, 0xa9, 0xc9, 0xa5, 0x25, 0xa9, 0x42,
	0x62, 0x7a, 0x50, 0x45, 0x50, 0x81, 0xa0, 0xd4, 0xc2, 0xd2, 0xd4, 0xe2, 0x12, 0x29, 0x71, 0x0c,
	0xf1, 0xe2, 0x82, 0xfc, 0xbc, 0xe2, 0x54, 0x25, 0x06, 0x21, 0x6f, 0x2e, 0x1e, 0xa8, 0xa0, 0x53,
	0x62, 0x49, 0x72, 0x86, 0x90, 0x34, 0x9a, 0x52, 0xb0, 0x28, 0xcc, 0x1c, 0x19, 0xec, 0x92, 0x70,
	0xc3, 0x02, 0xb8, 0x78, 0x83, 0x4b, 0x8a, 0x52, 0x13, 0x73, 0x61, 0x0e, 0x82, 0x6b, 0x40, 0x11,
	0x86, 0x19, 0x27, 0x8b, 0x43, 0x16, 0x66, 0x9e, 0x01, 0xa3, 0x50, 0x2c, 0x97, 0x50, 0x50, 0x6a,
	0x71, 0x7e, 0x4e, 0x59, 0x6a, 0x48, 0x51, 0x62, 0x5e, 0x71, 0x62, 0x72, 0x49, 0x66, 0x7e, 0x9e,
	0x90, 0x22, 0x4c, 0x23, 0xa6, 0x1c, 0xcc, 0x6c, 0x25, 0x7c, 0x4a, 0xe0, 0x0e, 0xb6, 0xe3, 0x62,
	0x0f, 0x83, 0x58, 0x8e, 0x08, 0x3b, 0xa8, 0x00, 0x46, 0xd8, 0xc1, 0xc5, 0x11, 0xce, 0x73, 0x0a,
	0x3a, 0xf1, 0x48, 0x8e, 0xf1, 0xc2, 0x23, 0x39, 0xc6, 0x07, 0x8f, 0xe4, 0x18, 0x67, 0x3c, 0x96,
	0x63, 0xe0, 0x12, 0xc9, 0xcc, 0xd7, 0x2b, 0x03, 0x47, 0x0c, 0x24, 0xa6, 0xf4, 0xd2, 0x8b, 0x0a,
	0x92, 0xa3, 0xb4, 0xa0, 0x42, 0x99, 0xf9, 0xfa, 0x10, 0x96, 0x7e, 0x7a, 0xbe, 0x7e, 0x59, 0x89,
	0x3e, 0x58, 0x89, 0x3e, 0x4a, 0x44, 0x27, 0xb1, 0x81, 0x05, 0x8d, 0x01, 0x01, 0x00, 0x00, 0xff,
	0xff, 0xb1, 0x89, 0xe2, 0xfd, 0x15, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VitessClient is the client API for Vitess service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VitessClient interface {
	// Execute tries to route the query to the right shard.
	// It depends on the query and bind variables to provide enough
	// information in conjunction with the vindexes to route the query.
	// API group: v3
	Execute(ctx context.Context, in *vtgate.ExecuteRequest, opts ...grpc.CallOption) (*vtgate.ExecuteResponse, error)
	// ExecuteBatch tries to route the list of queries on the right shards.
	// It depends on the query and bind variables to provide enough
	// information in conjunction with the vindexes to route the query.
	// API group: v3
	ExecuteBatch(ctx context.Context, in *vtgate.ExecuteBatchRequest, opts ...grpc.CallOption) (*vtgate.ExecuteBatchResponse, error)
	// StreamExecute executes a streaming query based on shards.
	// It depends on the query and bind variables to provide enough
	// information in conjunction with the vindexes to route the query.
	// Use this method if the query returns a large number of rows.
	// API group: v3
	StreamExecute(ctx context.Context, in *vtgate.StreamExecuteRequest, opts ...grpc.CallOption) (Vitess_StreamExecuteClient, error)
	// ResolveTransaction resolves a transaction.
	// API group: Transactions
	ResolveTransaction(ctx context.Context, in *vtgate.ResolveTransactionRequest, opts ...grpc.CallOption) (*vtgate.ResolveTransactionResponse, error)
	// VStream streams binlog events from the requested sources.
	VStream(ctx context.Context, in *vtgate.VStreamRequest, opts ...grpc.CallOption) (Vitess_VStreamClient, error)
}

type vitessClient struct {
	cc *grpc.ClientConn
}

func NewVitessClient(cc *grpc.ClientConn) VitessClient {
	return &vitessClient{cc}
}

func (c *vitessClient) Execute(ctx context.Context, in *vtgate.ExecuteRequest, opts ...grpc.CallOption) (*vtgate.ExecuteResponse, error) {
	out := new(vtgate.ExecuteResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/Execute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) ExecuteBatch(ctx context.Context, in *vtgate.ExecuteBatchRequest, opts ...grpc.CallOption) (*vtgate.ExecuteBatchResponse, error) {
	out := new(vtgate.ExecuteBatchResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/ExecuteBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) StreamExecute(ctx context.Context, in *vtgate.StreamExecuteRequest, opts ...grpc.CallOption) (Vitess_StreamExecuteClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Vitess_serviceDesc.Streams[0], "/vtgateservice.Vitess/StreamExecute", opts...)
	if err != nil {
		return nil, err
	}
	x := &vitessStreamExecuteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vitess_StreamExecuteClient interface {
	Recv() (*vtgate.StreamExecuteResponse, error)
	grpc.ClientStream
}

type vitessStreamExecuteClient struct {
	grpc.ClientStream
}

func (x *vitessStreamExecuteClient) Recv() (*vtgate.StreamExecuteResponse, error) {
	m := new(vtgate.StreamExecuteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vitessClient) ResolveTransaction(ctx context.Context, in *vtgate.ResolveTransactionRequest, opts ...grpc.CallOption) (*vtgate.ResolveTransactionResponse, error) {
	out := new(vtgate.ResolveTransactionResponse)
	err := c.cc.Invoke(ctx, "/vtgateservice.Vitess/ResolveTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vitessClient) VStream(ctx context.Context, in *vtgate.VStreamRequest, opts ...grpc.CallOption) (Vitess_VStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Vitess_serviceDesc.Streams[1], "/vtgateservice.Vitess/VStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &vitessVStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vitess_VStreamClient interface {
	Recv() (*vtgate.VStreamResponse, error)
	grpc.ClientStream
}

type vitessVStreamClient struct {
	grpc.ClientStream
}

func (x *vitessVStreamClient) Recv() (*vtgate.VStreamResponse, error) {
	m := new(vtgate.VStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// VitessServer is the server API for Vitess service.
type VitessServer interface {
	// Execute tries to route the query to the right shard.
	// It depends on the query and bind variables to provide enough
	// information in conjunction with the vindexes to route the query.
	// API group: v3
	Execute(context.Context, *vtgate.ExecuteRequest) (*vtgate.ExecuteResponse, error)
	// ExecuteBatch tries to route the list of queries on the right shards.
	// It depends on the query and bind variables to provide enough
	// information in conjunction with the vindexes to route the query.
	// API group: v3
	ExecuteBatch(context.Context, *vtgate.ExecuteBatchRequest) (*vtgate.ExecuteBatchResponse, error)
	// StreamExecute executes a streaming query based on shards.
	// It depends on the query and bind variables to provide enough
	// information in conjunction with the vindexes to route the query.
	// Use this method if the query returns a large number of rows.
	// API group: v3
	StreamExecute(*vtgate.StreamExecuteRequest, Vitess_StreamExecuteServer) error
	// ResolveTransaction resolves a transaction.
	// API group: Transactions
	ResolveTransaction(context.Context, *vtgate.ResolveTransactionRequest) (*vtgate.ResolveTransactionResponse, error)
	// VStream streams binlog events from the requested sources.
	VStream(*vtgate.VStreamRequest, Vitess_VStreamServer) error
}

// UnimplementedVitessServer can be embedded to have forward compatible implementations.
type UnimplementedVitessServer struct {
}

func (*UnimplementedVitessServer) Execute(ctx context.Context, req *vtgate.ExecuteRequest) (*vtgate.ExecuteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (*UnimplementedVitessServer) ExecuteBatch(ctx context.Context, req *vtgate.ExecuteBatchRequest) (*vtgate.ExecuteBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteBatch not implemented")
}
func (*UnimplementedVitessServer) StreamExecute(req *vtgate.StreamExecuteRequest, srv Vitess_StreamExecuteServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamExecute not implemented")
}
func (*UnimplementedVitessServer) ResolveTransaction(ctx context.Context, req *vtgate.ResolveTransactionRequest) (*vtgate.ResolveTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveTransaction not implemented")
}
func (*UnimplementedVitessServer) VStream(req *vtgate.VStreamRequest, srv Vitess_VStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method VStream not implemented")
}

func RegisterVitessServer(s *grpc.Server, srv VitessServer) {
	s.RegisterService(&_Vitess_serviceDesc, srv)
}

func _Vitess_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).Execute(ctx, req.(*vtgate.ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_ExecuteBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ExecuteBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).ExecuteBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/ExecuteBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).ExecuteBatch(ctx, req.(*vtgate.ExecuteBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_StreamExecute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtgate.StreamExecuteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VitessServer).StreamExecute(m, &vitessStreamExecuteServer{stream})
}

type Vitess_StreamExecuteServer interface {
	Send(*vtgate.StreamExecuteResponse) error
	grpc.ServerStream
}

type vitessStreamExecuteServer struct {
	grpc.ServerStream
}

func (x *vitessStreamExecuteServer) Send(m *vtgate.StreamExecuteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Vitess_ResolveTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtgate.ResolveTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VitessServer).ResolveTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtgateservice.Vitess/ResolveTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VitessServer).ResolveTransaction(ctx, req.(*vtgate.ResolveTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vitess_VStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtgate.VStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VitessServer).VStream(m, &vitessVStreamServer{stream})
}

type Vitess_VStreamServer interface {
	Send(*vtgate.VStreamResponse) error
	grpc.ServerStream
}

type vitessVStreamServer struct {
	grpc.ServerStream
}

func (x *vitessVStreamServer) Send(m *vtgate.VStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Vitess_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vtgateservice.Vitess",
	HandlerType: (*VitessServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Execute",
			Handler:    _Vitess_Execute_Handler,
		},
		{
			MethodName: "ExecuteBatch",
			Handler:    _Vitess_ExecuteBatch_Handler,
		},
		{
			MethodName: "ResolveTransaction",
			Handler:    _Vitess_ResolveTransaction_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamExecute",
			Handler:       _Vitess_StreamExecute_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "VStream",
			Handler:       _Vitess_VStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "vtgateservice.proto",
}
