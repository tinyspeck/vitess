// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: throttlerdata.proto

package throttlerdata

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// MaxRatesRequest is the payload for the MaxRates RPC.
type MaxRatesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MaxRatesRequest) Reset()         { *m = MaxRatesRequest{} }
func (m *MaxRatesRequest) String() string { return proto.CompactTextString(m) }
func (*MaxRatesRequest) ProtoMessage()    {}
func (*MaxRatesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{0}
}
func (m *MaxRatesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxRatesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxRatesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxRatesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxRatesRequest.Merge(m, src)
}
func (m *MaxRatesRequest) XXX_Size() int {
	return m.Size()
}
func (m *MaxRatesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxRatesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MaxRatesRequest proto.InternalMessageInfo

// MaxRatesResponse is returned by the MaxRates RPC.
type MaxRatesResponse struct {
	// max_rates returns the max rate for each throttler. It's keyed by the
	// throttler name.
	Rates                map[string]int64 `protobuf:"bytes,1,rep,name=rates,proto3" json:"rates,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *MaxRatesResponse) Reset()         { *m = MaxRatesResponse{} }
func (m *MaxRatesResponse) String() string { return proto.CompactTextString(m) }
func (*MaxRatesResponse) ProtoMessage()    {}
func (*MaxRatesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{1}
}
func (m *MaxRatesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxRatesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxRatesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxRatesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxRatesResponse.Merge(m, src)
}
func (m *MaxRatesResponse) XXX_Size() int {
	return m.Size()
}
func (m *MaxRatesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxRatesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MaxRatesResponse proto.InternalMessageInfo

func (m *MaxRatesResponse) GetRates() map[string]int64 {
	if m != nil {
		return m.Rates
	}
	return nil
}

// SetMaxRateRequest is the payload for the SetMaxRate RPC.
type SetMaxRateRequest struct {
	Rate                 int64    `protobuf:"varint,1,opt,name=rate,proto3" json:"rate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetMaxRateRequest) Reset()         { *m = SetMaxRateRequest{} }
func (m *SetMaxRateRequest) String() string { return proto.CompactTextString(m) }
func (*SetMaxRateRequest) ProtoMessage()    {}
func (*SetMaxRateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{2}
}
func (m *SetMaxRateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetMaxRateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetMaxRateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetMaxRateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetMaxRateRequest.Merge(m, src)
}
func (m *SetMaxRateRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetMaxRateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetMaxRateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetMaxRateRequest proto.InternalMessageInfo

func (m *SetMaxRateRequest) GetRate() int64 {
	if m != nil {
		return m.Rate
	}
	return 0
}

// SetMaxRateResponse is returned by the SetMaxRate RPC.
type SetMaxRateResponse struct {
	// names is the list of throttler names which were updated.
	Names                []string `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetMaxRateResponse) Reset()         { *m = SetMaxRateResponse{} }
func (m *SetMaxRateResponse) String() string { return proto.CompactTextString(m) }
func (*SetMaxRateResponse) ProtoMessage()    {}
func (*SetMaxRateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{3}
}
func (m *SetMaxRateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetMaxRateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetMaxRateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetMaxRateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetMaxRateResponse.Merge(m, src)
}
func (m *SetMaxRateResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetMaxRateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetMaxRateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetMaxRateResponse proto.InternalMessageInfo

func (m *SetMaxRateResponse) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

// Configuration holds the configuration parameters for the
// MaxReplicationLagModule which adaptively adjusts the throttling rate based on
// the observed replication lag across all replicas.
type Configuration struct {
	// target_replication_lag_sec is the replication lag (in seconds) the
	// MaxReplicationLagModule tries to aim for.
	// If it is within the target, it tries to increase the throttler
	// rate, otherwise it will lower it based on an educated guess of the
	// replica's throughput.
	TargetReplicationLagSec int64 `protobuf:"varint,1,opt,name=target_replication_lag_sec,json=targetReplicationLagSec,proto3" json:"target_replication_lag_sec,omitempty"`
	// max_replication_lag_sec is meant as a last resort.
	// By default, the module tries to find out the system maximum capacity while
	// trying to keep the replication lag around "target_replication_lag_sec".
	// Usually, we'll wait min_duration_between_(increases|decreases)_sec to see
	// the effect of a throttler rate change on the replication lag.
	// But if the lag goes above this field's value we will go into an "emergency"
	// state and throttle more aggressively (see "emergency_decrease" below).
	// This is the only way to ensure that the system will recover.
	MaxReplicationLagSec int64 `protobuf:"varint,2,opt,name=max_replication_lag_sec,json=maxReplicationLagSec,proto3" json:"max_replication_lag_sec,omitempty"`
	// initial_rate is the rate at which the module will start.
	InitialRate int64 `protobuf:"varint,3,opt,name=initial_rate,json=initialRate,proto3" json:"initial_rate,omitempty"`
	// max_increase defines by how much we will increase the rate
	// e.g. 0.05 increases the rate by 5% while 1.0 by 100%.
	// Note that any increase will let the system wait for at least
	// (1 / MaxIncrease) seconds. If we wait for shorter periods of time, we
	// won't notice if the rate increase also increases the replication lag.
	// (If the system was already at its maximum capacity (e.g. 1k QPS) and we
	// increase the rate by e.g. 5% to 1050 QPS, it will take 20 seconds until
	// 1000 extra queries are buffered and the lag increases by 1 second.)
	MaxIncrease float64 `protobuf:"fixed64,4,opt,name=max_increase,json=maxIncrease,proto3" json:"max_increase,omitempty"`
	// emergency_decrease defines by how much we will decrease the current rate
	// if the observed replication lag is above "max_replication_lag_sec".
	// E.g. 0.50 decreases the current rate by 50%.
	EmergencyDecrease float64 `protobuf:"fixed64,5,opt,name=emergency_decrease,json=emergencyDecrease,proto3" json:"emergency_decrease,omitempty"`
	// min_duration_between_increases_sec specifies how long we'll wait at least
	// for the last rate increase to have an effect on the system.
	MinDurationBetweenIncreasesSec int64 `protobuf:"varint,6,opt,name=min_duration_between_increases_sec,json=minDurationBetweenIncreasesSec,proto3" json:"min_duration_between_increases_sec,omitempty"`
	// max_duration_between_increases_sec specifies how long we'll wait at most
	// for the last rate increase to have an effect on the system.
	MaxDurationBetweenIncreasesSec int64 `protobuf:"varint,7,opt,name=max_duration_between_increases_sec,json=maxDurationBetweenIncreasesSec,proto3" json:"max_duration_between_increases_sec,omitempty"`
	// min_duration_between_decreases_sec specifies how long we'll wait at least
	// for the last rate decrease to have an effect on the system.
	MinDurationBetweenDecreasesSec int64 `protobuf:"varint,8,opt,name=min_duration_between_decreases_sec,json=minDurationBetweenDecreasesSec,proto3" json:"min_duration_between_decreases_sec,omitempty"`
	// spread_backlog_across_sec is used when we set the throttler rate after
	// we guessed the rate of a replica and determined its backlog.
	// For example, at a guessed rate of 100 QPS and a lag of 10s, the replica has
	// a backlog of 1000 queries.
	// When we set the new, decreased throttler rate, we factor in how long it
	// will take the replica to go through the backlog (in addition to new
	// requests). This field specifies over which timespan we plan to spread this.
	// For example, for a backlog of 1000 queries spread over 5s means that we
	// have to further reduce the rate by 200 QPS or the backlog will not be
	// processed within the 5 seconds.
	SpreadBacklogAcrossSec int64 `protobuf:"varint,9,opt,name=spread_backlog_across_sec,json=spreadBacklogAcrossSec,proto3" json:"spread_backlog_across_sec,omitempty"`
	// ignore_n_slowest_replicas will ignore replication lag updates from the
	// N slowest REPLICA tablets. Under certain circumstances, replicas are still
	// considered e.g. a) if the lag is at most max_replication_lag_sec, b) there
	// are less than N+1 replicas or c) the lag increased on each replica such
	// that all replicas were ignored in a row.
	IgnoreNSlowestReplicas int32 `protobuf:"varint,10,opt,name=ignore_n_slowest_replicas,json=ignoreNSlowestReplicas,proto3" json:"ignore_n_slowest_replicas,omitempty"`
	// ignore_n_slowest_rdonlys does the same thing as ignore_n_slowest_replicas
	// but for RDONLY tablets. Note that these two settings are independent.
	IgnoreNSlowestRdonlys int32 `protobuf:"varint,11,opt,name=ignore_n_slowest_rdonlys,json=ignoreNSlowestRdonlys,proto3" json:"ignore_n_slowest_rdonlys,omitempty"`
	// age_bad_rate_after_sec is the duration after which an unchanged bad rate
	// will "age out" and increase by "bad_rate_increase".
	// Bad rates are tracked by the code in memory.go and serve as an upper bound
	// for future rate changes. This ensures that the adaptive throttler does not
	// try known too high (bad) rates over and over again.
	// To avoid that temporary degradations permanently reduce the maximum rate,
	// a stable bad rate "ages out" after "age_bad_rate_after_sec".
	AgeBadRateAfterSec int64 `protobuf:"varint,12,opt,name=age_bad_rate_after_sec,json=ageBadRateAfterSec,proto3" json:"age_bad_rate_after_sec,omitempty"`
	// bad_rate_increase defines the percentage by which a bad rate will be
	// increased when it's aging out.
	BadRateIncrease float64 `protobuf:"fixed64,13,opt,name=bad_rate_increase,json=badRateIncrease,proto3" json:"bad_rate_increase,omitempty"`
	// max_rate_approach_threshold is the fraction of the current rate limit that the actual
	// rate must exceed for the throttler to increase the limit when the replication lag
	// is below target_replication_lag_sec. For example, assuming the actual replication lag
	// is below target_replication_lag_sec, if the current rate limit is 100, then the actual
	// rate must exceed 100*max_rate_approach_threshold for the throttler to increase the current
	// limit.
	MaxRateApproachThreshold float64  `protobuf:"fixed64,14,opt,name=max_rate_approach_threshold,json=maxRateApproachThreshold,proto3" json:"max_rate_approach_threshold,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *Configuration) Reset()         { *m = Configuration{} }
func (m *Configuration) String() string { return proto.CompactTextString(m) }
func (*Configuration) ProtoMessage()    {}
func (*Configuration) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{4}
}
func (m *Configuration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Configuration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Configuration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Configuration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Configuration.Merge(m, src)
}
func (m *Configuration) XXX_Size() int {
	return m.Size()
}
func (m *Configuration) XXX_DiscardUnknown() {
	xxx_messageInfo_Configuration.DiscardUnknown(m)
}

var xxx_messageInfo_Configuration proto.InternalMessageInfo

func (m *Configuration) GetTargetReplicationLagSec() int64 {
	if m != nil {
		return m.TargetReplicationLagSec
	}
	return 0
}

func (m *Configuration) GetMaxReplicationLagSec() int64 {
	if m != nil {
		return m.MaxReplicationLagSec
	}
	return 0
}

func (m *Configuration) GetInitialRate() int64 {
	if m != nil {
		return m.InitialRate
	}
	return 0
}

func (m *Configuration) GetMaxIncrease() float64 {
	if m != nil {
		return m.MaxIncrease
	}
	return 0
}

func (m *Configuration) GetEmergencyDecrease() float64 {
	if m != nil {
		return m.EmergencyDecrease
	}
	return 0
}

func (m *Configuration) GetMinDurationBetweenIncreasesSec() int64 {
	if m != nil {
		return m.MinDurationBetweenIncreasesSec
	}
	return 0
}

func (m *Configuration) GetMaxDurationBetweenIncreasesSec() int64 {
	if m != nil {
		return m.MaxDurationBetweenIncreasesSec
	}
	return 0
}

func (m *Configuration) GetMinDurationBetweenDecreasesSec() int64 {
	if m != nil {
		return m.MinDurationBetweenDecreasesSec
	}
	return 0
}

func (m *Configuration) GetSpreadBacklogAcrossSec() int64 {
	if m != nil {
		return m.SpreadBacklogAcrossSec
	}
	return 0
}

func (m *Configuration) GetIgnoreNSlowestReplicas() int32 {
	if m != nil {
		return m.IgnoreNSlowestReplicas
	}
	return 0
}

func (m *Configuration) GetIgnoreNSlowestRdonlys() int32 {
	if m != nil {
		return m.IgnoreNSlowestRdonlys
	}
	return 0
}

func (m *Configuration) GetAgeBadRateAfterSec() int64 {
	if m != nil {
		return m.AgeBadRateAfterSec
	}
	return 0
}

func (m *Configuration) GetBadRateIncrease() float64 {
	if m != nil {
		return m.BadRateIncrease
	}
	return 0
}

func (m *Configuration) GetMaxRateApproachThreshold() float64 {
	if m != nil {
		return m.MaxRateApproachThreshold
	}
	return 0
}

// GetConfigurationRequest is the payload for the GetConfiguration RPC.
type GetConfigurationRequest struct {
	// throttler_name specifies which throttler to select. If empty, all active
	// throttlers will be selected.
	ThrottlerName        string   `protobuf:"bytes,1,opt,name=throttler_name,json=throttlerName,proto3" json:"throttler_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetConfigurationRequest) Reset()         { *m = GetConfigurationRequest{} }
func (m *GetConfigurationRequest) String() string { return proto.CompactTextString(m) }
func (*GetConfigurationRequest) ProtoMessage()    {}
func (*GetConfigurationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{5}
}
func (m *GetConfigurationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfigurationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfigurationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfigurationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigurationRequest.Merge(m, src)
}
func (m *GetConfigurationRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetConfigurationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigurationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigurationRequest proto.InternalMessageInfo

func (m *GetConfigurationRequest) GetThrottlerName() string {
	if m != nil {
		return m.ThrottlerName
	}
	return ""
}

// GetConfigurationResponse is returned by the GetConfiguration RPC.
type GetConfigurationResponse struct {
	// max_rates returns the configurations for each throttler.
	// It's keyed by the throttler name.
	Configurations       map[string]*Configuration `protobuf:"bytes,1,rep,name=configurations,proto3" json:"configurations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *GetConfigurationResponse) Reset()         { *m = GetConfigurationResponse{} }
func (m *GetConfigurationResponse) String() string { return proto.CompactTextString(m) }
func (*GetConfigurationResponse) ProtoMessage()    {}
func (*GetConfigurationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{6}
}
func (m *GetConfigurationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConfigurationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConfigurationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConfigurationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConfigurationResponse.Merge(m, src)
}
func (m *GetConfigurationResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetConfigurationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConfigurationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetConfigurationResponse proto.InternalMessageInfo

func (m *GetConfigurationResponse) GetConfigurations() map[string]*Configuration {
	if m != nil {
		return m.Configurations
	}
	return nil
}

// UpdateConfigurationRequest is the payload for the UpdateConfiguration RPC.
type UpdateConfigurationRequest struct {
	// throttler_name specifies which throttler to update. If empty, all active
	// throttlers will be updated.
	ThrottlerName string `protobuf:"bytes,1,opt,name=throttler_name,json=throttlerName,proto3" json:"throttler_name,omitempty"`
	// configuration is the new (partial) configuration.
	Configuration *Configuration `protobuf:"bytes,2,opt,name=configuration,proto3" json:"configuration,omitempty"`
	// copy_zero_values specifies whether fields with zero values should be copied
	// as well.
	CopyZeroValues       bool     `protobuf:"varint,3,opt,name=copy_zero_values,json=copyZeroValues,proto3" json:"copy_zero_values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateConfigurationRequest) Reset()         { *m = UpdateConfigurationRequest{} }
func (m *UpdateConfigurationRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateConfigurationRequest) ProtoMessage()    {}
func (*UpdateConfigurationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{7}
}
func (m *UpdateConfigurationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateConfigurationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateConfigurationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateConfigurationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateConfigurationRequest.Merge(m, src)
}
func (m *UpdateConfigurationRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateConfigurationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateConfigurationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateConfigurationRequest proto.InternalMessageInfo

func (m *UpdateConfigurationRequest) GetThrottlerName() string {
	if m != nil {
		return m.ThrottlerName
	}
	return ""
}

func (m *UpdateConfigurationRequest) GetConfiguration() *Configuration {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *UpdateConfigurationRequest) GetCopyZeroValues() bool {
	if m != nil {
		return m.CopyZeroValues
	}
	return false
}

// UpdateConfigurationResponse is returned by the UpdateConfiguration RPC.
type UpdateConfigurationResponse struct {
	// names is the list of throttler names which were updated.
	Names                []string `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateConfigurationResponse) Reset()         { *m = UpdateConfigurationResponse{} }
func (m *UpdateConfigurationResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateConfigurationResponse) ProtoMessage()    {}
func (*UpdateConfigurationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{8}
}
func (m *UpdateConfigurationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateConfigurationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateConfigurationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateConfigurationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateConfigurationResponse.Merge(m, src)
}
func (m *UpdateConfigurationResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateConfigurationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateConfigurationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateConfigurationResponse proto.InternalMessageInfo

func (m *UpdateConfigurationResponse) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

// ResetConfigurationRequest is the payload for the ResetConfiguration RPC.
type ResetConfigurationRequest struct {
	// throttler_name specifies which throttler to reset. If empty, all active
	// throttlers will be reset.
	ThrottlerName        string   `protobuf:"bytes,1,opt,name=throttler_name,json=throttlerName,proto3" json:"throttler_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetConfigurationRequest) Reset()         { *m = ResetConfigurationRequest{} }
func (m *ResetConfigurationRequest) String() string { return proto.CompactTextString(m) }
func (*ResetConfigurationRequest) ProtoMessage()    {}
func (*ResetConfigurationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{9}
}
func (m *ResetConfigurationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetConfigurationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetConfigurationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetConfigurationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetConfigurationRequest.Merge(m, src)
}
func (m *ResetConfigurationRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResetConfigurationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetConfigurationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResetConfigurationRequest proto.InternalMessageInfo

func (m *ResetConfigurationRequest) GetThrottlerName() string {
	if m != nil {
		return m.ThrottlerName
	}
	return ""
}

// ResetConfigurationResponse is returned by the ResetConfiguration RPC.
type ResetConfigurationResponse struct {
	// names is the list of throttler names which were updated.
	Names                []string `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetConfigurationResponse) Reset()         { *m = ResetConfigurationResponse{} }
func (m *ResetConfigurationResponse) String() string { return proto.CompactTextString(m) }
func (*ResetConfigurationResponse) ProtoMessage()    {}
func (*ResetConfigurationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b67db2b008a2453d, []int{10}
}
func (m *ResetConfigurationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetConfigurationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetConfigurationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetConfigurationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetConfigurationResponse.Merge(m, src)
}
func (m *ResetConfigurationResponse) XXX_Size() int {
	return m.Size()
}
func (m *ResetConfigurationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetConfigurationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResetConfigurationResponse proto.InternalMessageInfo

func (m *ResetConfigurationResponse) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

func init() {
	proto.RegisterType((*MaxRatesRequest)(nil), "throttlerdata.MaxRatesRequest")
	proto.RegisterType((*MaxRatesResponse)(nil), "throttlerdata.MaxRatesResponse")
	proto.RegisterMapType((map[string]int64)(nil), "throttlerdata.MaxRatesResponse.RatesEntry")
	proto.RegisterType((*SetMaxRateRequest)(nil), "throttlerdata.SetMaxRateRequest")
	proto.RegisterType((*SetMaxRateResponse)(nil), "throttlerdata.SetMaxRateResponse")
	proto.RegisterType((*Configuration)(nil), "throttlerdata.Configuration")
	proto.RegisterType((*GetConfigurationRequest)(nil), "throttlerdata.GetConfigurationRequest")
	proto.RegisterType((*GetConfigurationResponse)(nil), "throttlerdata.GetConfigurationResponse")
	proto.RegisterMapType((map[string]*Configuration)(nil), "throttlerdata.GetConfigurationResponse.ConfigurationsEntry")
	proto.RegisterType((*UpdateConfigurationRequest)(nil), "throttlerdata.UpdateConfigurationRequest")
	proto.RegisterType((*UpdateConfigurationResponse)(nil), "throttlerdata.UpdateConfigurationResponse")
	proto.RegisterType((*ResetConfigurationRequest)(nil), "throttlerdata.ResetConfigurationRequest")
	proto.RegisterType((*ResetConfigurationResponse)(nil), "throttlerdata.ResetConfigurationResponse")
}

func init() { proto.RegisterFile("throttlerdata.proto", fileDescriptor_b67db2b008a2453d) }

var fileDescriptor_b67db2b008a2453d = []byte{
	// 761 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0x5f, 0x6f, 0xe3, 0x44,
	0x10, 0xc7, 0x97, 0x4b, 0xb9, 0x4e, 0x2e, 0xbd, 0x66, 0xaf, 0xb4, 0xbe, 0x1c, 0x8a, 0x82, 0x25,
	0x44, 0x14, 0x89, 0x44, 0xca, 0x09, 0x71, 0x50, 0x90, 0xda, 0x50, 0x84, 0x40, 0xd0, 0x07, 0x17,
	0x78, 0xe8, 0xcb, 0x6a, 0x63, 0x4f, 0x1d, 0xab, 0xb6, 0xd7, 0xec, 0x6e, 0xdb, 0x84, 0x0f, 0xc1,
	0x33, 0x9f, 0x81, 0x37, 0xbe, 0x05, 0x8f, 0x7c, 0x84, 0xaa, 0x7c, 0x11, 0xe4, 0xdd, 0xcd, 0x1f,
	0xa7, 0x69, 0x7b, 0x52, 0xdf, 0x76, 0x67, 0x7e, 0xf3, 0x9b, 0xdf, 0xac, 0x67, 0xc6, 0xf0, 0x52,
	0x8d, 0x05, 0x57, 0x2a, 0x41, 0x11, 0x32, 0xc5, 0x7a, 0xb9, 0xe0, 0x8a, 0x93, 0x7a, 0xc9, 0xe8,
	0x35, 0xe0, 0xc5, 0x4f, 0x6c, 0xe2, 0x33, 0x85, 0xd2, 0xc7, 0xdf, 0x2e, 0x50, 0x2a, 0xef, 0x0f,
	0x07, 0xb6, 0x17, 0x36, 0x99, 0xf3, 0x4c, 0x22, 0x39, 0x80, 0xaa, 0x28, 0x0c, 0xae, 0xd3, 0xae,
	0x74, 0x6a, 0x83, 0x6e, 0xaf, 0xcc, 0xbd, 0x8a, 0xef, 0xe9, 0xdb, 0xb7, 0x99, 0x12, 0x53, 0xdf,
	0x04, 0x36, 0xdf, 0x02, 0x2c, 0x8c, 0x64, 0x1b, 0x2a, 0xe7, 0x38, 0x75, 0x9d, 0xb6, 0xd3, 0xd9,
	0xf4, 0x8b, 0x23, 0xd9, 0x81, 0xea, 0x25, 0x4b, 0x2e, 0xd0, 0x7d, 0xd2, 0x76, 0x3a, 0x15, 0xdf,
	0x5c, 0xbe, 0x7c, 0xf2, 0xd6, 0xf1, 0x3e, 0x81, 0xc6, 0x09, 0x2a, 0x9b, 0xc2, 0xaa, 0x24, 0x04,
	0x9e, 0x16, 0xbc, 0x9a, 0xa1, 0xe2, 0xeb, 0xb3, 0xd7, 0x05, 0xb2, 0x0c, 0xb4, 0xd2, 0x77, 0xa0,
	0x9a, 0xb1, 0xd4, 0x4a, 0xdf, 0xf4, 0xcd, 0xc5, 0xfb, 0x6b, 0x03, 0xea, 0xdf, 0xf0, 0xec, 0x2c,
	0x8e, 0x2e, 0x04, 0x53, 0x31, 0xcf, 0xc8, 0x3e, 0x34, 0x15, 0x13, 0x11, 0x2a, 0x2a, 0x30, 0x4f,
	0xe2, 0x40, 0x5b, 0x69, 0xc2, 0x22, 0x2a, 0x31, 0xb0, 0x79, 0xf6, 0x0c, 0xc2, 0x5f, 0x00, 0x7e,
	0x64, 0xd1, 0x09, 0x06, 0xe4, 0x33, 0xd8, 0x4b, 0xd9, 0x64, 0x6d, 0xa4, 0xa9, 0x67, 0x27, 0x65,
	0x93, 0xdb, 0x61, 0x1f, 0xc1, 0xf3, 0x38, 0x8b, 0x55, 0xcc, 0x12, 0xaa, 0xab, 0xa9, 0x68, 0x6c,
	0xcd, 0xda, 0x8a, 0x32, 0x0a, 0x48, 0xc1, 0x1c, 0x67, 0x81, 0x40, 0x26, 0xd1, 0x7d, 0xda, 0x76,
	0x3a, 0x8e, 0x5f, 0x4b, 0xd9, 0xe4, 0x7b, 0x6b, 0x22, 0x9f, 0x02, 0xc1, 0x14, 0x45, 0x84, 0x59,
	0x30, 0xa5, 0x21, 0x5a, 0x60, 0x55, 0x03, 0x1b, 0x73, 0xcf, 0x91, 0x75, 0x90, 0x1f, 0xc0, 0x4b,
	0xe3, 0x8c, 0x86, 0xb6, 0x70, 0x3a, 0x42, 0x75, 0x85, 0x98, 0xcd, 0x53, 0x48, 0x2d, 0x7b, 0x43,
	0x4b, 0x69, 0xa5, 0x71, 0x76, 0x64, 0x81, 0x43, 0x83, 0x9b, 0xa5, 0x95, 0x45, 0x01, 0x05, 0x17,
	0x9b, 0x3c, 0xc4, 0xf5, 0xbe, 0xe5, 0x62, 0x93, 0x87, 0xb8, 0xd6, 0xe9, 0x9a, 0x55, 0x64, 0xb8,
	0x9e, 0xdd, 0xa5, 0x6b, 0x56, 0x9f, 0xe6, 0xfa, 0x02, 0x5e, 0xc9, 0x5c, 0x20, 0x0b, 0xe9, 0x88,
	0x05, 0xe7, 0x09, 0x8f, 0x28, 0x0b, 0x04, 0x97, 0x86, 0x62, 0x53, 0x53, 0xec, 0x1a, 0xc0, 0xd0,
	0xf8, 0x0f, 0xb5, 0xdb, 0x86, 0xc6, 0x51, 0xc6, 0x05, 0xd2, 0x8c, 0xca, 0x84, 0x5f, 0xa1, 0x9c,
	0x77, 0x84, 0x74, 0xa1, 0xed, 0x74, 0xaa, 0xfe, 0xae, 0x01, 0x1c, 0x9f, 0x18, 0xb7, 0xfd, 0xae,
	0x92, 0x7c, 0x0e, 0xee, 0xed, 0xd0, 0x90, 0x67, 0xc9, 0x54, 0xba, 0x35, 0x1d, 0xf9, 0xc1, 0x4a,
	0xa4, 0x71, 0x92, 0x01, 0xec, 0xb2, 0x08, 0xe9, 0x88, 0x85, 0xba, 0x0f, 0x28, 0x3b, 0x53, 0x28,
	0xb4, 0xd6, 0xe7, 0x5a, 0x2b, 0x61, 0x11, 0x0e, 0x59, 0x58, 0x34, 0xc4, 0x61, 0xe1, 0x2a, 0x74,
	0x76, 0xa1, 0x31, 0xc7, 0xcf, 0xbb, 0xa3, 0xae, 0x3f, 0xfa, 0x8b, 0x91, 0xc1, 0xce, 0x3b, 0xe4,
	0x6b, 0x78, 0xad, 0xdb, 0x53, 0x73, 0xe7, 0xb9, 0xe0, 0x2c, 0x18, 0x53, 0x35, 0x16, 0x28, 0xc7,
	0x3c, 0x09, 0xdd, 0x2d, 0x1d, 0xe5, 0xa6, 0x66, 0x72, 0x0e, 0x2d, 0xe0, 0xe7, 0x99, 0xdf, 0x3b,
	0x80, 0xbd, 0xef, 0x50, 0x95, 0xc6, 0x65, 0x36, 0x87, 0x1f, 0xc3, 0xd6, 0x7c, 0x15, 0xd0, 0x62,
	0xb4, 0xec, 0x4c, 0x2f, 0xf6, 0xcc, 0x31, 0x4b, 0xd1, 0xbb, 0x76, 0xc0, 0xbd, 0x4d, 0x61, 0x27,
	0x34, 0x80, 0xad, 0x60, 0xd9, 0x31, 0xdb, 0x32, 0xfb, 0x2b, 0x5b, 0xe6, 0x2e, 0x82, 0x5e, 0xc9,
	0x6a, 0xd7, 0xce, 0x0a, 0x65, 0x93, 0xc2, 0xcb, 0x35, 0xb0, 0x35, 0x8b, 0x68, 0xb0, 0xbc, 0x88,
	0x6a, 0x83, 0x0f, 0x57, 0x44, 0x94, 0x15, 0x2c, 0xad, 0xa9, 0xbf, 0x1d, 0x68, 0xfe, 0x92, 0x87,
	0x4c, 0xe1, 0x23, 0x1e, 0x8a, 0x0c, 0xa1, 0x5e, 0x12, 0xfe, 0x4e, 0x2a, 0xca, 0x21, 0xa4, 0x03,
	0xdb, 0x01, 0xcf, 0xa7, 0xf4, 0x77, 0x14, 0x9c, 0x6a, 0x81, 0x52, 0x6f, 0x96, 0x67, 0xc5, 0xa3,
	0xe4, 0xd3, 0x53, 0x14, 0xfc, 0x57, 0x6d, 0xf5, 0xde, 0xc0, 0xeb, 0xb5, 0x92, 0xef, 0x5d, 0x9d,
	0x43, 0x78, 0xe5, 0xa3, 0x7c, 0x5c, 0x3f, 0x0c, 0xa0, 0xb9, 0x8e, 0xe3, 0xbe, 0xbc, 0xc3, 0xaf,
	0xfe, 0xb9, 0x69, 0x39, 0xff, 0xde, 0xb4, 0x9c, 0xeb, 0x9b, 0x96, 0xf3, 0xe7, 0x7f, 0xad, 0xf7,
	0x4e, 0xbb, 0x97, 0xb1, 0x42, 0x29, 0x7b, 0x31, 0xef, 0x9b, 0x53, 0x3f, 0xe2, 0xfd, 0x4b, 0xd5,
	0xd7, 0xbf, 0xba, 0x7e, 0xe9, 0xc5, 0x46, 0x1b, 0xda, 0xf8, 0xe6, 0xff, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x85, 0x05, 0xbd, 0x73, 0x16, 0x07, 0x00, 0x00,
}

func (m *MaxRatesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxRatesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxRatesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MaxRatesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxRatesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxRatesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rates) > 0 {
		for k := range m.Rates {
			v := m.Rates[k]
			baseI := i
			i = encodeVarintThrottlerdata(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintThrottlerdata(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintThrottlerdata(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetMaxRateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetMaxRateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetMaxRateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rate != 0 {
		i = encodeVarintThrottlerdata(dAtA, i, uint64(m.Rate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetMaxRateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetMaxRateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetMaxRateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Names[iNdEx])
			copy(dAtA[i:], m.Names[iNdEx])
			i = encodeVarintThrottlerdata(dAtA, i, uint64(len(m.Names[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Configuration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Configuration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Configuration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxRateApproachThreshold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxRateApproachThreshold))))
		i--
		dAtA[i] = 0x71
	}
	if m.BadRateIncrease != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BadRateIncrease))))
		i--
		dAtA[i] = 0x69
	}
	if m.AgeBadRateAfterSec != 0 {
		i = encodeVarintThrottlerdata(dAtA, i, uint64(m.AgeBadRateAfterSec))
		i--
		dAtA[i] = 0x60
	}
	if m.IgnoreNSlowestRdonlys != 0 {
		i = encodeVarintThrottlerdata(dAtA, i, uint64(m.IgnoreNSlowestRdonlys))
		i--
		dAtA[i] = 0x58
	}
	if m.IgnoreNSlowestReplicas != 0 {
		i = encodeVarintThrottlerdata(dAtA, i, uint64(m.IgnoreNSlowestReplicas))
		i--
		dAtA[i] = 0x50
	}
	if m.SpreadBacklogAcrossSec != 0 {
		i = encodeVarintThrottlerdata(dAtA, i, uint64(m.SpreadBacklogAcrossSec))
		i--
		dAtA[i] = 0x48
	}
	if m.MinDurationBetweenDecreasesSec != 0 {
		i = encodeVarintThrottlerdata(dAtA, i, uint64(m.MinDurationBetweenDecreasesSec))
		i--
		dAtA[i] = 0x40
	}
	if m.MaxDurationBetweenIncreasesSec != 0 {
		i = encodeVarintThrottlerdata(dAtA, i, uint64(m.MaxDurationBetweenIncreasesSec))
		i--
		dAtA[i] = 0x38
	}
	if m.MinDurationBetweenIncreasesSec != 0 {
		i = encodeVarintThrottlerdata(dAtA, i, uint64(m.MinDurationBetweenIncreasesSec))
		i--
		dAtA[i] = 0x30
	}
	if m.EmergencyDecrease != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.EmergencyDecrease))))
		i--
		dAtA[i] = 0x29
	}
	if m.MaxIncrease != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxIncrease))))
		i--
		dAtA[i] = 0x21
	}
	if m.InitialRate != 0 {
		i = encodeVarintThrottlerdata(dAtA, i, uint64(m.InitialRate))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxReplicationLagSec != 0 {
		i = encodeVarintThrottlerdata(dAtA, i, uint64(m.MaxReplicationLagSec))
		i--
		dAtA[i] = 0x10
	}
	if m.TargetReplicationLagSec != 0 {
		i = encodeVarintThrottlerdata(dAtA, i, uint64(m.TargetReplicationLagSec))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetConfigurationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfigurationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfigurationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ThrottlerName) > 0 {
		i -= len(m.ThrottlerName)
		copy(dAtA[i:], m.ThrottlerName)
		i = encodeVarintThrottlerdata(dAtA, i, uint64(len(m.ThrottlerName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetConfigurationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConfigurationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConfigurationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Configurations) > 0 {
		for k := range m.Configurations {
			v := m.Configurations[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintThrottlerdata(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintThrottlerdata(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintThrottlerdata(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateConfigurationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateConfigurationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateConfigurationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CopyZeroValues {
		i--
		if m.CopyZeroValues {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Configuration != nil {
		{
			size, err := m.Configuration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintThrottlerdata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ThrottlerName) > 0 {
		i -= len(m.ThrottlerName)
		copy(dAtA[i:], m.ThrottlerName)
		i = encodeVarintThrottlerdata(dAtA, i, uint64(len(m.ThrottlerName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateConfigurationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateConfigurationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateConfigurationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Names[iNdEx])
			copy(dAtA[i:], m.Names[iNdEx])
			i = encodeVarintThrottlerdata(dAtA, i, uint64(len(m.Names[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResetConfigurationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetConfigurationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetConfigurationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ThrottlerName) > 0 {
		i -= len(m.ThrottlerName)
		copy(dAtA[i:], m.ThrottlerName)
		i = encodeVarintThrottlerdata(dAtA, i, uint64(len(m.ThrottlerName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResetConfigurationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetConfigurationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetConfigurationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Names[iNdEx])
			copy(dAtA[i:], m.Names[iNdEx])
			i = encodeVarintThrottlerdata(dAtA, i, uint64(len(m.Names[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintThrottlerdata(dAtA []byte, offset int, v uint64) int {
	offset -= sovThrottlerdata(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MaxRatesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaxRatesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rates) > 0 {
		for k, v := range m.Rates {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovThrottlerdata(uint64(len(k))) + 1 + sovThrottlerdata(uint64(v))
			n += mapEntrySize + 1 + sovThrottlerdata(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetMaxRateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rate != 0 {
		n += 1 + sovThrottlerdata(uint64(m.Rate))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetMaxRateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovThrottlerdata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Configuration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetReplicationLagSec != 0 {
		n += 1 + sovThrottlerdata(uint64(m.TargetReplicationLagSec))
	}
	if m.MaxReplicationLagSec != 0 {
		n += 1 + sovThrottlerdata(uint64(m.MaxReplicationLagSec))
	}
	if m.InitialRate != 0 {
		n += 1 + sovThrottlerdata(uint64(m.InitialRate))
	}
	if m.MaxIncrease != 0 {
		n += 9
	}
	if m.EmergencyDecrease != 0 {
		n += 9
	}
	if m.MinDurationBetweenIncreasesSec != 0 {
		n += 1 + sovThrottlerdata(uint64(m.MinDurationBetweenIncreasesSec))
	}
	if m.MaxDurationBetweenIncreasesSec != 0 {
		n += 1 + sovThrottlerdata(uint64(m.MaxDurationBetweenIncreasesSec))
	}
	if m.MinDurationBetweenDecreasesSec != 0 {
		n += 1 + sovThrottlerdata(uint64(m.MinDurationBetweenDecreasesSec))
	}
	if m.SpreadBacklogAcrossSec != 0 {
		n += 1 + sovThrottlerdata(uint64(m.SpreadBacklogAcrossSec))
	}
	if m.IgnoreNSlowestReplicas != 0 {
		n += 1 + sovThrottlerdata(uint64(m.IgnoreNSlowestReplicas))
	}
	if m.IgnoreNSlowestRdonlys != 0 {
		n += 1 + sovThrottlerdata(uint64(m.IgnoreNSlowestRdonlys))
	}
	if m.AgeBadRateAfterSec != 0 {
		n += 1 + sovThrottlerdata(uint64(m.AgeBadRateAfterSec))
	}
	if m.BadRateIncrease != 0 {
		n += 9
	}
	if m.MaxRateApproachThreshold != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetConfigurationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ThrottlerName)
	if l > 0 {
		n += 1 + l + sovThrottlerdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetConfigurationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Configurations) > 0 {
		for k, v := range m.Configurations {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovThrottlerdata(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovThrottlerdata(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovThrottlerdata(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateConfigurationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ThrottlerName)
	if l > 0 {
		n += 1 + l + sovThrottlerdata(uint64(l))
	}
	if m.Configuration != nil {
		l = m.Configuration.Size()
		n += 1 + l + sovThrottlerdata(uint64(l))
	}
	if m.CopyZeroValues {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateConfigurationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovThrottlerdata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResetConfigurationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ThrottlerName)
	if l > 0 {
		n += 1 + l + sovThrottlerdata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResetConfigurationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovThrottlerdata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovThrottlerdata(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozThrottlerdata(x uint64) (n int) {
	return sovThrottlerdata(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MaxRatesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThrottlerdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxRatesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxRatesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipThrottlerdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxRatesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThrottlerdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxRatesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxRatesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rates == nil {
				m.Rates = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowThrottlerdata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowThrottlerdata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthThrottlerdata
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthThrottlerdata
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowThrottlerdata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipThrottlerdata(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthThrottlerdata
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Rates[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThrottlerdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetMaxRateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThrottlerdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetMaxRateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetMaxRateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipThrottlerdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetMaxRateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThrottlerdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetMaxRateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetMaxRateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThrottlerdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Configuration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThrottlerdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Configuration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Configuration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetReplicationLagSec", wireType)
			}
			m.TargetReplicationLagSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetReplicationLagSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReplicationLagSec", wireType)
			}
			m.MaxReplicationLagSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxReplicationLagSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialRate", wireType)
			}
			m.InitialRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialRate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxIncrease", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxIncrease = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmergencyDecrease", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.EmergencyDecrease = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDurationBetweenIncreasesSec", wireType)
			}
			m.MinDurationBetweenIncreasesSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDurationBetweenIncreasesSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDurationBetweenIncreasesSec", wireType)
			}
			m.MaxDurationBetweenIncreasesSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDurationBetweenIncreasesSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDurationBetweenDecreasesSec", wireType)
			}
			m.MinDurationBetweenDecreasesSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDurationBetweenDecreasesSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpreadBacklogAcrossSec", wireType)
			}
			m.SpreadBacklogAcrossSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpreadBacklogAcrossSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreNSlowestReplicas", wireType)
			}
			m.IgnoreNSlowestReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IgnoreNSlowestReplicas |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreNSlowestRdonlys", wireType)
			}
			m.IgnoreNSlowestRdonlys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IgnoreNSlowestRdonlys |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgeBadRateAfterSec", wireType)
			}
			m.AgeBadRateAfterSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgeBadRateAfterSec |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadRateIncrease", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BadRateIncrease = float64(math.Float64frombits(v))
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRateApproachThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxRateApproachThreshold = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipThrottlerdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfigurationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThrottlerdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfigurationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfigurationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThrottlerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThrottlerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThrottlerdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConfigurationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThrottlerdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConfigurationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConfigurationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configurations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configurations == nil {
				m.Configurations = make(map[string]*Configuration)
			}
			var mapkey string
			var mapvalue *Configuration
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowThrottlerdata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowThrottlerdata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthThrottlerdata
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthThrottlerdata
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowThrottlerdata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthThrottlerdata
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthThrottlerdata
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Configuration{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipThrottlerdata(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthThrottlerdata
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Configurations[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThrottlerdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateConfigurationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThrottlerdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateConfigurationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateConfigurationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThrottlerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThrottlerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Configuration == nil {
				m.Configuration = &Configuration{}
			}
			if err := m.Configuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyZeroValues", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyZeroValues = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipThrottlerdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateConfigurationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThrottlerdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateConfigurationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateConfigurationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThrottlerdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetConfigurationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThrottlerdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetConfigurationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetConfigurationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThrottlerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThrottlerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThrottlerdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetConfigurationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowThrottlerdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetConfigurationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetConfigurationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipThrottlerdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthThrottlerdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipThrottlerdata(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowThrottlerdata
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowThrottlerdata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthThrottlerdata
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupThrottlerdata
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthThrottlerdata
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthThrottlerdata        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowThrottlerdata          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupThrottlerdata = fmt.Errorf("proto: unexpected end of group")
)
